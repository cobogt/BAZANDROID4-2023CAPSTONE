package com.jgt.wizelinebaz2023.storage/** * * * * * * * * * * Project KoreFrame * Created by Jacobo G Tamayo on 30/12/22.* * * * * * * * * * **/import kotlinx.coroutines.CoroutineScopeimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.flow.Flowimport kotlinx.coroutines.flow.MutableStateFlowimport kotlinx.coroutines.flow.emitAllimport kotlinx.coroutines.flow.flowimport kotlinx.coroutines.flow.mapNotNullimport kotlinx.coroutines.launchimport retrofit2.HttpExceptionimport java.io.IOExceptionsealed interface RepositoryStrategy {    /**     * Estrategia para leer información de la red y persistirla en local     *     * Tipo R: Tipo de dato del parámetro de entrada para llamar a la fuente remota     * Tipo S: Resultado de la función de transformación (T -> S)     * Tipo T: Tipo de dato del resultado de la llamada a la fuente de datos local     */    data class FetchTransformAndStoreStrategy<R, L, M>(        /** Llamada a la fuente de datos remota */        val remoteSourceData: suspend () -> R,        /** Fuente local observable */        val localSourceData: suspend () -> Flow<L>,        /** Transforma la respuesta de la llamada LOCAL de la capa DATA,         *  devuelve Modelos de la capa DOMAIN */        val localToModelTransform: suspend (L) -> M,        /** Transforma la respuesta de la llamada REMOTA de la capa DATA, devuelve         * Modelos de la  capa DOMINIO */        val remoteToModelTransform: suspend (R) -> M,        /** Almacena el resultado de la función de transformación (Opcional) */        val storeModelTransformation: (suspend (M) -> Unit)? = null    ): RepositoryStrategy {        /**         * Ejecuta la petición a la fuente remota para luego transformar la respuesta y si está         * definida la función de almacenamiento se ejecuta con la respuesta transformada.         *         * Consume una fuente local observable, y en cada emisión de valores se usa la         * función de transformación para mapear el resultado. Si está definida la función de         * almacenamiento, guarda el resultado de la transformación invocandola.         */        fun consume(): Flow<M> =            flow {                try {                    fetch()                }catch (eIO: IOException) {                    /* Este bloque permite trabajar offline */                }catch (eHttp: HttpException){                    /* Este bloque permite trabajar sin servicio */                }                emitAll(                    localSourceData                        .invoke()                        .mapNotNull { localResult ->                            localResult?.let {                                localToModelTransform( localResult )                            }                        }                )            }        /**         * Envuelve el resultado del flujo consumido en un recurso         */        fun consumeAsResource(): Flow<Resource<M>> =            flow {                emit( Resource.loading() )                try {                    try { fetch() }                    catch (e: IOException) {                        emit( Resource.error( e, "Error de red" ))                    }                    catch (e: HttpException) {                        emit( Resource.error( e, "Error en la petición" ))                    }                    emitAll(                        localSourceData                            .invoke()                            .mapNotNull { localResult ->                                localResult?.let {                                    Resource.success(                                        localToModelTransform( localResult )                                    )                                }                            }                    )                }catch (e: Exception) {                    emit( Resource.error( e ) )                }            }        /**         * Reintenta la operación de consumo de fuente remota, transformación         * de respuesta y almacenamiento del resultado transformado.         *         * Esta operación se puede ejecutar sin consumir la estrategia si solo se busca         * hacer la petición, transformar la respuesta y persistir el resultado.         */        suspend fun fetch() = remoteSourceData.invoke().also {            val remoteResponse = remoteSourceData.invoke()            CoroutineScope(Dispatchers.IO).launch {                storeModelTransformation?.invoke(                    remoteToModelTransform ( remoteResponse)                )            }        }    }    /**     * Estrategia para consumir información de la red y transformarla a un modelo local sin     * persistir pero pudiendo reintentar la operación.     */    data class FetchAndTransformStrategy<R, M>(        /** Llamada a la fuente de datos remota */        val remoteSourceData:       suspend () -> R,        /** Transforma la respuesta de la llamada REMOTA de la capa DATA, devuelve         * Modelos de la  capa DOMINIO */        val remoteToModelTransform: suspend (R) -> M,        /** Almacena el resultado de la función de transformación (Opcional) */        val storeModelTransformation:      (suspend (M) -> Unit)? = null,    ): RepositoryStrategy {        private var virtualStorage: MutableStateFlow<R?> = MutableStateFlow( null )        fun consume(): Flow<M> = flow {            try {                fetch()            }catch (eIO: IOException) {                /* Este bloque permite trabajar offline */            }catch (eHttp: HttpException){                /* Este bloque permite trabajar sin servicio */            }            emitAll(                virtualStorage.mapNotNull {                    it?.let { remoteData ->                        remoteToModelTransform.invoke( remoteData )                    }                }            )        }        fun consumeAsResource(): Flow<Resource<M>> = flow {            try {                emit( Resource.loading() )                try { fetch() }                catch (e: IOException) {                    emit( Resource.error( e, "Error de red" ))                }                catch (e: HttpException) {                    emit( Resource.error( e, "Error en la petición" ))                }                emitAll(                    virtualStorage.mapNotNull {                        it?.let { remoteData ->                            Resource.success( remoteToModelTransform.invoke( remoteData ) )                        }                    }                )            } catch ( e: Exception ) {                emit( Resource.error( e ) )            }        }        suspend fun fetch() {            val remoteData = remoteSourceData.invoke()            virtualStorage.value = remoteData            CoroutineScope( Dispatchers.IO ).launch{                storeModelTransformation?.invoke(                    remoteToModelTransform.invoke( remoteData )                )            }        }    }}